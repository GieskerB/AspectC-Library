#pragma once

#include <exception>
#include <string>
#include <vector>

#include "../core/core_aspect.ah"
#include "../util/printer.hh"
#include "../util/stack_trace_msg_builder.hh"

namespace acp {
	attribute trace();
}

aspect StackTrace : public CoreAspect {


	pointcut virtual ignore() = "% StackTrace::...::%(...)" || "% acp::...::%(...)";

//	pointcut virtual default_where() = acp::trace();
	pointcut virtual default_where() = everywhere();

	pointcut virtual fall_back_func() = "int main(...)";

private:

	/**
	 * @brief Flag to indicate if we are currently editing the stack trace.
	 *
	 * Since an Aspect is always a singleton, the static thread_local variable acts as a member variable on thread level.
	 *
	 * While this value is true, entering a function will not reset the stack trace in the event of an exception.
	 * This is important because in the process of handling the exception in this Aspect, function calls may occurs whilst
	 * not having dealt with the exception itself.
	 */
	static thread_local bool _editing_stack_trace;

	/**
	 * @brief Pointer to the last thrown exception.
	 *
	 * Since an Aspect is always a singleton, the static thread_local variable acts as a member variable on thread level.
	 *
	 * This is used to check if the exception has changed or not. In case a function catches an exception and throws another
	 * again, the stacktrace should reset.
	 */
	static thread_local std::exception const* _last_thrown;

	/**
	 * @brief Ordered list of all function calls from the occurrence of the exception to the current function.
	 *
	 * Since an Aspect is always a singleton, the static thread_local variable acts as a member variable on thread level.
	 *
	 * Allready stores the correctly formatted error message. Therefore, simple printing the content of this list in order
	 * will result in a correct stack trace.
	 */
	static thread_local std::vector<std::string> _call_chain;


	/**
	 * @brief Check if the stack trace should be reset.
	 *
	 * When calling - therefore entering - a function, the exception must have been resolved. So if the first thing an
	 * advice should do is call this function before proceeding.
	 */
	void check_reset() {
		// When calling a function, the exception must have been resolved
		if (_last_thrown != nullptr and !_editing_stack_trace) {
			_last_thrown = nullptr;
			_call_chain.clear();
		}
	}

protected:

	/**
	 * @brief Create a formatted error message.
	 *
	 * @param sign Signature of the function.
	 * @param file Name of the file of the function.
	 * @param line Line number of the function call.
	 * @return Formatted error message.
	 */
	std::string create_err_msg(const char* sign, const char* file, int line) {
		std::string err_msg { };
		err_msg += "at ";
		err_msg += sign; // implicit conversion to std::string
		err_msg += " in (";
		err_msg += file; // implicit conversion to std::string
		err_msg += ':';
		err_msg += std::to_string(line);
		err_msg += ")\n";
		return err_msg;
	}

	/**
	 * @brief Print the stack trace.
	 *
	 * @param call_chain List of function calls.
	 * @param exception_msg Exception message.
	 */
	void print_stack_trace(const std::vector<std::string>& call_chain, const char* exception_msg) {
		_printer->print("\n\nUncaught exception ");
		_printer->print(exception_msg);
		_printer->print(":\n");
		for (const auto& err_msg : _call_chain) {
			_printer->print('\t');
			_printer->print(err_msg);
		}
		// Reset values after printing.
		_last_thrown = nullptr;
		_printer->print("\n\n");
		_editing_stack_trace = false;
	}

public:

	StackTrace() : StackTrace(nullptr,nullptr) {}

	StackTrace(acp::StackTraceMsgBuilder* builder, acp::Printer* printer) : _builder(builder), _printer(printer) {}

	virtual ~StackTrace() {
		delete _builder;
		delete _printer;
	}

	/**
	 * @brief Pointcut to exclude certain functions from being traced.
	 */
	pointcut dont_trace() = "% StackTrace::...::%(...)" || "% acp::...::%(...)";


	/**
	 * @brief Pointcut which includes every function call. This should be the default pointcut for best stacktrace results.
	 */
	pointcut everywhere() = "% ...::%(...)";

	/**
	 * @brief Pointcut which states around which functions this StackTrace should act upon. Defaults to only functions
	 * annotated with this [[acp::trace]] attribute.
	 */
	pointcut virtual where() = acp::trace();


	/**
	 * @brief Pointcut which states for which one (or multiple) function(s) the StackTrace print is triggered when an
	 * uncaught exception leaves that function. Defaults to the main function.
	 */
	pointcut virtual fall_back_func() = "int main(...)";

	/**
	 * @brief Advice handles the StackTrace printing when an uncaught exception leaves the function of the pointcut.
	 */
	advice execution(fall_back_func()) : around() {

		check_reset();

		try {
			tjp->proceed();
		} catch (const std::exception& e) {
			_editing_stack_trace = true;
			_call_chain.push_back(_builder->build_msg(tjp->signature(),tjp->filename(),tjp->line()));
			// Print Stack Trace
			print_stack_trace(_call_chain, e.what());
			return;
		} catch (...) {
			// Not implemented yet.
		}
	}

	advice call(where() && !ignore()) : around(){

		check_reset();

		try {
			tjp->proceed();
		} catch (const std::exception& e) {
			_editing_stack_trace = true;
			if (_last_thrown == nullptr) {
				// Just thrown
				_call_chain.push_back(_builder->build_msg(tjp->signature(),tjp->filename(),tjp->line()));
				_last_thrown = &e;
			} else if (typeid(*_last_thrown) == typeid(e) and std::string(_last_thrown->what()) == std::string(e.what())) {
				// Exception is still the same
				_call_chain.push_back(_builder->build_msg(tjp->signature(),tjp->filename(),tjp->line()));
			} else {
				// Exception changed
				_call_chain.clear();
				_call_chain.push_back(_builder->build_msg(tjp->signature(),tjp->filename(),tjp->line()));
				_last_thrown = &e;
			}
			_editing_stack_trace = false;
			throw;
		} catch (...) {
			// Not implemented yet.
		}
	}
};


thread_local bool StackTrace::_editing_stack_trace = false;

thread_local std::exception const* StackTrace::_last_thrown = nullptr;

thread_local std::vector<std::string> StackTrace::_call_chain{};
