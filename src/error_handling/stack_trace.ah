#pragma once

#include <iostream>
#include <exception>
#include <cstring>
#include <vector>
#include <sstream>

namespace acp {
attribute trace();
}

aspect StackTrace {

private:

	static thread_local bool _editing_stack_trace;

	static thread_local std::exception const* _last_thrown;

	static thread_local std::vector<std::string> _call_chain;


	void check_reset() {
		// When calling a function, the exception must have been resolved
		if (_last_thrown != nullptr and !_editing_stack_trace) {
			_last_thrown = nullptr;
			_call_chain.clear();
		}
	}

protected:

	std::string create_err_msg(const char* sign, const char* file, int line) {
		std::string err_msg { };
		err_msg += "at ";
		err_msg += sign; // implicit conversion to std::string
		err_msg += " in (";
		err_msg += file; // implicit conversion to std::string
		err_msg += ':';
		err_msg += std::to_string(line);
		err_msg += ")\n";
		return err_msg;
	}

	void print_stack_trace(const std::vector<std::string>& call_chain, const char* exception_msg) {
		std::cerr << "\n\nUncaught exception " << exception_msg << ":\n";
		for (const auto& err_msg : _call_chain) {
			std::cerr << '\t' << err_msg;
		}
		// Reset values after printing.
		_last_thrown = nullptr;
		std::cerr << "\n\n";
		_editing_stack_trace = false;
	}

public:

	pointcut dont_trace() = "% StackTrace::...::%(...)" || "% acp::...::%(...)";

	pointcut everywhere() = "% ...::%(...)";

	pointcut virtual where() = acp::trace();

	pointcut virtual fall_back_func() = "int main(...)";

	StackTrace() {}

	virtual ~StackTrace() {}

	advice execution(fall_back_func()) : around() {

		check_reset();

		try {
			tjp->proceed();
		} catch (const std::exception& e) {
			_editing_stack_trace = true;
			_call_chain.push_back(create_err_msg(tjp->signature(),tjp->filename(),tjp->line()));
			// Print Stack Trace
			print_stack_trace(_call_chain, e.what());
			return;
		} catch (...) {
			// Not implemented yet.
		}
	}

	advice call(where() && !dont_trace()) : around(){

		check_reset();

		try {
			tjp->proceed();
		} catch (const std::exception& e) {
			_editing_stack_trace = true;
			if (_last_thrown == nullptr) {
				// Just thrown
				_call_chain.push_back(create_err_msg(tjp->signature(),tjp->filename(),tjp->line()));
				_last_thrown = &e;
			} else if (typeid(*_last_thrown) == typeid(e) and std::string(_last_thrown->what()) == std::string(e.what())) {
				// Exception is still the same
				_call_chain.push_back(create_err_msg(tjp->signature(),tjp->filename(),tjp->line()));
			} else {
				// Exception changed
				_call_chain.clear();
				_call_chain.push_back(create_err_msg(tjp->signature(),tjp->filename(),tjp->line()));
				_last_thrown = &e;
			}
			_editing_stack_trace = false;
			throw;
		} catch (...) {
			// Not implemented yet.
		}
	}
};


thread_local bool StackTrace::_editing_stack_trace = false;

thread_local std::exception const* StackTrace::_last_thrown = nullptr;

thread_local std::vector<std::string> StackTrace::_call_chain{};
