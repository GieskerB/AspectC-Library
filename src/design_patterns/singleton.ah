#ifndef __ACP__SINGLETON_AH__
#define __ACP__SINGLETON_AH__

#include "../core/core_aspect.ah"
#include "../util/thread_controller.hh"

namespace acp {
    attribute singleton();

    slice class ACP_Singleton_Slice {

        static bool acp_singleton_allow_construction;

    public:
        static JoinPoint::That* get_instance() {
            static JoinPoint::That* instance = nullptr;
            if (instance == nullptr) {
                acp_singleton_allow_construction = true;
                instance = new JoinPoint::That();
                acp_singleton_allow_construction = false;
            }
            return instance;
        }
    };

    slice bool ACP_Singleton_Slice::acp_singleton_allow_construction = false;
}

aspect Singleton {

    acp::ThreadController* _thread;

    public:

     /**
     * \pointcut default_where
     * \see :ref:`CoreAspect::default_where <core_aspect_ah_default_where>`
     */
    pointcut virtual default_where() = acp::singleton();

    /**
     * \pointcut ignore
     * \see :ref:`CoreAspect::ignore <core_aspect_ah_ignore>`
     */
    pointcut virtual ignore() = within("Singleton") || within("acp");

    Singleton(): Singleton(nullptr) {}
    Singleton(acp::ThreadController* thread): _thread(thread) {}
    virtual ~Singleton() = default;

    advice acp::singleton() : slice acp::ACP_Singleton_Slice;

    advice construction(acp::singleton()) : around() {
        _thread->acquire_lock();
        if(JoinPoint::That::acp_singleton_allow_construction) {
            tjp->proceed();
            _thread->release_lock();
        } else {
            _thread->release_lock();
            throw std::runtime_error("Singleton construction is not allowed. Use get_instance() instead.");
        }
    }
};

#endif // __ACP__SINGLETON_AH__
