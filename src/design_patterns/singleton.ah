#ifndef __ACP__SINGLETON_AH__
#define __ACP__SINGLETON_AH__

#include "../core/core_aspect.ah"
#include "../util/thread_controller.hh"

#include <vector>

namespace acp {
    /**
     * \attribute singleton
     * \brief This attribute is used to mark classes as singletons.
     */
    attribute singleton();

    slice class ACP_Singleton_Slice {

        static bool acp_singleton_allow_construction;
        static void* acp_singleton_instance;

        static void acp_singleton_destroy_instance() {
            if (acp_singleton_instance != nullptr) {
                delete static_cast<JoinPoint::That*>(acp_singleton_instance);
                acp_singleton_instance = nullptr;
            }
        }

    public:
        static JoinPoint::That& get_instance() {
            if (acp_singleton_instance == nullptr) {
                acp_singleton_allow_construction = true;
                acp_singleton_instance = new JoinPoint::That();
                std::atexit(&acp_singleton_destroy_instance);
                acp_singleton_allow_construction = false;
            }
            return *static_cast<JoinPoint::That*>(acp_singleton_instance);
        }
    };

    slice bool ACP_Singleton_Slice::acp_singleton_allow_construction = false;
    slice void* ACP_Singleton_Slice::acp_singleton_instance = nullptr;
}

/**
 * \aspect Singleton
 * \file src/design_patterns/singleton.ah
 * \brief This aspect implements the Singleton design pattern.
 *
 * This aspect ensures that any class annotated with this specific attribute can have only
 * one instance and provides a global access point to that instance. A static get_instance()
 * method is provided to retrieve the instance, and construction of the singleton instance.
 *
 * When calling any constructor of a class annotated with this aspect, a runtime error will
 * be thrown.
 *
 */
aspect Singleton {

    acp::ThreadController* _thread;
    std::vector<void**> _singleton_instances;

    public:

     /**
     * \pointcut default_where
     * \see :ref:`CoreAspect::default_where <core_aspect_ah_default_where>`
     */
    pointcut virtual default_where() = acp::singleton();

    /**
     * \pointcut ignore
     * \see :ref:`CoreAspect::ignore <core_aspect_ah_ignore>`
     */
    pointcut virtual ignore() = within("Singleton") || within("acp");

    Singleton(): Singleton(nullptr) {}
    Singleton(acp::ThreadController* thread): _thread(thread) {}
    virtual ~Singleton() {
        // if (_thread) {
        //     _thread->acquire_lock();
        //     for (auto& instance : _singleton_instances) {
        //         if (*instance != nullptr) {
        //             (*instance)->acp_singleton_destroy_instance();
        //         }
        //     }
        //     _singleton_instances.clear();
        //     _thread->release_lock();
        // }
    }

    /**
     * \advice singleton-slice
     * \brief This advice provides a class with all necessary methods and members
     * to implement the Singleton design pattern.
     */
    advice acp::singleton() : slice acp::ACP_Singleton_Slice;

    /**
     * \advice construction-prevention
     * \brief This advice prevents the construction of a singleton class directly.
     */
    advice construction(acp::singleton()) : around() {
        _thread->acquire_lock();
        if(JoinPoint::That::acp_singleton_allow_construction) {
            tjp->proceed();
            _singleton_instances.push_back(&JoinPoint::That::acp_singleton_instance);
            _thread->release_lock();
        } else {
            _thread->release_lock();
            throw std::runtime_error("Singleton construction is not allowed. Use get_instance() instead.");
        }
    }

    advice destruction(acp::singleton()) : after() {
        _thread->acquire_lock();
        if(JoinPoint::That::acp_singleton_instance != nullptr) {
            delete static_cast<JoinPoint::That*>(JoinPoint::That::acp_singleton_instance);
            JoinPoint::That::acp_singleton_instance = nullptr;
        }
        _thread->release_lock();
        std::cout << "Singleton instance destroyed." << std::endl;
    }
};

#endif // __ACP__SINGLETON_AH__
