#ifndef __ACP__PROFILER_AH__
#define __ACP__PROFILER_AH__

#include <iostream>
#include <chrono>


namespace acp {

	struct ProfilerData {
		static ProfilerData* &first () { static ProfilerData *data = 0; return data; }
		struct ProfilerData* p_next;
		unsigned int m_calls;
		std::chrono::nanoseconds m_exec_time;
		const char* m_signature;
		ProfilerData (const char* n) : m_calls{0}, m_exec_time{0L}, m_signature{n} {
			ProfilerData *head = first ();
			first () = this;
			p_next = head;
		}
	};

}

namespace acp {

	attribute profile();

}

aspect Profiler {

protected:

	std::ostream* _os;

public:

    pointcut dont_profile() = "% Profiler::...::%(...)" || "% acp::...::%(...)";

    pointcut virtual where() = acp::profile();

    pointcut base_where() = acp::profile();

    Profiler(): Profiler(std::cout) {}

    Profiler(std::ostream& os): _os(&os){

    }

    advice execution(where() && !dont_profile()) : around() {
    	static acp::ProfilerData data (JoinPoint::signature());
		const auto start = std::chrono::high_resolution_clock::now();
		tjp->proceed();
		const auto end = std::chrono::high_resolution_clock::now();
		data.m_calls++;
		data.m_exec_time += end - start;
    }

    static void simple_stat () {
		for (acp::ProfilerData *curr = acp::ProfilerData::first (); curr; curr = curr->p_next) {
			std::cout << curr->m_signature << ": called "
					  << curr->m_calls << " times within "
					  << curr->m_exec_time.count() << " nanosec.\n";
		}
    	std::cout << "\n\n";
      }

    virtual void (*summary())() {
        return &simple_stat;
      }

    advice execution ("% main(...)") : after () {
        atexit (summary());
      }

};

#endif // __ACP__PROFILER_AH__
