#pragma once

#include <iostream>
#include <chrono>


namespace acp {

	struct ProfilerData {
		static ProfilerData* &first () { static ProfilerData *data = 0; return data; }
		struct ProfilerData* p_next;
		unsigned int m_calls;
		std::chrono::nanoseconds m_exec_time;
		const char* m_signature;
		ProfilerData (const char* n) : m_calls{0}, m_exec_time{0L}, m_signature{n} {
			ProfilerData *head = first ();
			first () = this;
			p_next = head;
		}
	};

}

namespace acp {

	attribute profile();

}

aspect ProfilerBase {

protected:

	std::ostream* _os;

public:

    pointcut dont_profile() = "% ProfilerBase::...::%(...)" || "% acp::...::%(...)";

    pointcut virtual where() = acp::profile();

    pointcut base_where() = acp::profile();

    ProfilerBase(): ProfilerBase(std::cout) {}

    ProfilerBase(std::ostream& os): _os(&os){

    }

    virtual ~ProfilerBase() {
    	simple_stat();
    }


    advice execution(where() && !dont_profile()) : around() {
    	static acp::ProfilerData data (JoinPoint::signature());

//    	std::cerr << "<<"<< JoinPoint::signature()<< ">>\n";

		const auto start = std::chrono::high_resolution_clock::now();
		tjp->proceed();
		const auto end = std::chrono::high_resolution_clock::now();
		data.m_calls++;
		data.m_exec_time += end - start;
    }

    static void simple_stat () {
//        std::cout << "Statistics:\n";

    	std::cout << "\n\n";
		for (acp::ProfilerData *curr = acp::ProfilerData::first (); curr; curr = curr->p_next) {
			std::cout << curr->m_signature << ": called "
					  << curr->m_calls << " times within "
					  << curr->m_exec_time.count() << " nanosec.\n";
		}

      }

    virtual void (*summary())() {
        return &simple_stat;
      }

};
